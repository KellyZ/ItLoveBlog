##  选择排序（冒泡排序）

每次都从剩余的数据中选择出最大（或最小）放到已排序数据的后面；

缺点：每次都需要将所有**未排序**的数据相互比较得到最大（或最小）的数据，增加了比较次数；

时间复杂度：O(n^2)

## 插入排序

每次都从剩余的数据中选择一个（比如第一个）插入到已排序数据中某个正确的位置；

优点：剩余**未排序**数据间不再相互比较，而是拿未排序的某个数据和**已排序**数据进行比较，插入到正确的位置，很显然一旦找到正确位置将不再需要继续比较；

缺点：假如某个数据相对大于（或小于）已排序的数据，那么这个数据将可能要和所有已排序的数据进行比较，一步步的插入到最前面（或最后面）

## 希尔排序

上述插入排序中需要从**已排序**中一步步找到正确位置，而随机随机性绝对了这里面有相当多的“多余”的比较交换动作，既然随机性：那就将整个随机序列按间隔为h的元素形成子序列（共分割成h个子序列，每个子序列最多N/h+1个元素），然后对每个子序列进行**插入排序**：

    for (int i=h; i<N; i++)  //h个子序列一起插入排序，h~2h是h个子序列的第二个元素
    {   //将a[i]插入到a[i-h], a[i-2h], a[i-3h]...这个已排序的序列中，注入是插入
        for (int j=i; j>=h && less(a[j], a[j-h]); j -=h )
        {
            exch(a, j, j-h);
        }
    }

然后不断减少h，直至h为1，及整个序列插入排序（如果是从小到大排列，此时大部分小数据在前面，大部分大数据在后面）

那么h初始为多少？以及h的递减规则如何？哪种是最优的？目前无法证明哪个是“最优的”。

比如h可以按下生1, 4, 13, 40... 这样的序列：

    while (h < N/3 ) h=3*h + 1;

## 归并排序

对无序序列的左右两个子序列分别排序，然后将两个子序列归并，两个子序列可以继续这样递归操作进行排序，如此，就好像颗倒立的树一样，不断的拆分排序然后归并；

## 快速排序

归并排序默认是对半分，快速排序是随机切分，关键在切分：一般的策略是先随意选取a[lo]作为切分元素，然后左右扫描交换，使得切分位置所有左边元素都小于切分元素，右边元素都大于切分元素。

## 堆排序

## 参考


1. http://jsrun.it/norahiko/oxIy  （排序可视化）